<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Hex Bouncer — Minimal Rebuild</title>
<script>
// =================== CONFIG ===================
const CFG = {
  canvasSize: 900,
  worldScale: 400,         // hex radius
  openEdgeIndex: 0,        // 0..5, which edge is open

  // Gameplay
  startLives: 5,
  baseBalls: 3,            // + red target
  levelClearBonus: 250,
  timeScoreRate: 3,

  // Physics / speeds
  dt: 1/60,
  speedMul: 1.25,
  redSpeedRange: [130, 185],     // ↑ min speed bumped slightly
  normalSpeedRange: [90, 210],
  redBounce: 0.96,
  normalBounceRange: [0.84, 0.97],

  // Visuals
  colors: {
    bg0: '#030712', bg1: '#0b1220',
    edge: '#38bdf8', edgeGlow: '#22d3ee',
    red: '#ef4444', redOutline: '#fca5a5',
    normal: '#93c5fd', normalOutline: '#60a5fa'
  }
};
// ==============================================
</script>
<style>
  :root { --ui: #e5e7eb; }
  html, body { height: 100svh; margin: 0; background:#0a0a0a; color:var(--ui); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow:hidden; overscroll-behavior:none; }
  .wrap { height:100%; display:grid; place-items:center; gap:14px; padding:16px; padding-bottom:calc(16px + env(safe-area-inset-bottom)); padding-top:calc(16px + env(safe-area-inset-top)); }
  canvas { width:min(92vmin,860px); height:min(92vmin,860px); max-width:100%; max-height:100%; background: radial-gradient(1200px at 50% 55%, #0f172a 0%, #0b0b0f 55%, #060608 100%); border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,.6), inset 0 0 60px rgba(0,0,0,.4); }
  .frame{ width:min(92vmin,860px); }
  .topbar{ display:grid; grid-template-columns:1fr 1fr; gap:20px; align-items:center; justify-items:stretch; }
  .stats{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:6px; margin-bottom:6px; }
  .pill{ padding:0; border-radius:12px; background:transparent; border:0; font-weight:600; font-size:clamp(18px,3.6vw,26px); }
  .btn{ cursor:pointer; border:none; background:linear-gradient(180deg,#38bdf8,#0ea5e9); color:#fff; font-weight:700; padding:10px 14px; border-radius:12px; box-shadow:0 8px 18px rgba(56,189,248,.35); }
  .btn.top{ padding:16px 0; font-size:clamp(18px,3.8vw,24px); }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .controls{ display:flex; justify-content:space-between; align-items:center; gap:12px; width:min(92vmin,860px); margin-top:14px; }
  .arrow{ min-width:100px; min-height:80px; font-size:22px; user-select:none; -webkit-user-select:none; opacity:.5; }
  .arrow.active{ transform:translateY(1px) scale(0.98); }
.title{ width:min(92vmin,860px); text-align:center; margin:8px 0 4px; font-size:clamp(20px,4.2vw,28px); font-weight:800; }
  .controls-hint{ flex:1; text-align:center; font-weight:600; font-size:clamp(14px,3.6vw,18px); opacity:.9; }
</style>
</head>
<body>
<div class="wrap">
  <h1 class="title frame">Welcome to Hex Bouncer</h1>
  <div class="topbar frame">
    <button class="btn top" id="startBtn">Start</button>
    <button class="btn top" id="resetBtn">Reset</button>
  </div>

  <div class="stats frame">
    <span class="pill" id="score">Score: 0</span>
    <span class="pill" id="lives">Lives: 5</span>
    <span class="pill" id="level">Level: 1</span>
  </div>

  <canvas id="game" width="900" height="900"></canvas>

  <div class="controls frame">
    <button class="btn arrow" id="leftBtn" aria-label="Rotate Left">◀</button>
    <div class="controls-hint">Get only the red ball out of the hex</div>
    <button class="btn arrow" id="rightBtn" aria-label="Rotate Right">▶</button>
  </div>

  <!-- Keep Pause for gameplay but not in the topbar layout -->
  <button class="btn" id="pauseBtn" style="display:none">Pause</button>
</div>

<script>
// ======= STATE =======
const state = {
  running:false, paused:false, lastFrame:0,
  angle:0,
  score:0, lives:CFG.startLives, level:1,
  balls:[], redBallId:null,
};

// ======= CANVAS =======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

// ======= AUDIO =======
let audioCtx = null;
function ensureAudio(){
  if (!audioCtx){ const AC = window.AudioContext || window.webkitAudioContext; if (AC) audioCtx = new AC(); }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}
function beep(freq=600, dur=0.08, type='sine', vol=0.06){
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type; osc.frequency.setValueAtTime(freq, now);
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(vol, now + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + dur + 0.02);
}
function playBounce(){ beep(520, 0.06, 'square', 0.05); }
function playDing(){ beep(880, 0.12, 'sine', 0.06); setTimeout(()=>beep(1320, 0.10, 'sine', 0.05), 60); }

// ======= INPUT =======
const keys = new Set();
window.addEventListener('keydown', e=>{
  if (e.key==='ArrowLeft'||e.key==='ArrowRight'){ e.preventDefault(); keys.add(e.key); }
  if (e.key===' '&&state.running){ togglePause(); }
});
window.addEventListener('keyup', e=>{
  if (e.key==='ArrowLeft'||e.key==='ArrowRight') keys.delete(e.key);
});
function bindArrow(btn,key){
  const down=e=>{ e.preventDefault(); keys.add(key); btn.classList.add('active'); };
  const up=e=>{ e.preventDefault(); keys.delete(key); btn.classList.remove('active'); };
  btn.addEventListener('pointerdown',down);
  btn.addEventListener('pointerup',up);
  btn.addEventListener('pointercancel',up);
  btn.addEventListener('pointerleave',up);
  window.addEventListener('pointerup',up);
}
bindArrow(leftBtn,'ArrowLeft');
bindArrow(rightBtn,'ArrowRight');

startBtn.onclick=()=>{
  if (!state.running){
    ensureAudio();
    state.running=true; startBtn.disabled=true; pauseBtn.disabled=false; state.lastFrame=performance.now();
    resetRound();
    loop(state.lastFrame);
  }
};
pauseBtn.onclick=togglePause;
resetBtn.onclick=()=>{ startBtn.disabled=false; pauseBtn.disabled=true; hardReset(); };

function togglePause(){ if(!state.running) return; state.paused=!state.paused; pauseBtn.textContent=state.paused?'Resume':'Pause'; if(!state.paused){ state.lastFrame=performance.now(); loop(state.lastFrame);} }

// ======= GEOMETRY =======
function getHexVertices(angle=0){
  const R=CFG.worldScale, v=[];
  for(let i=0;i<6;i++){ const a=angle+Math.PI/6+i*Math.PI/3; v.push({x:R*Math.cos(a), y:R*Math.sin(a)}); }
  return v;
}
function edgeList(angle=0){ const vs=getHexVertices(angle); const e=[]; for(let i=0;i<6;i++){ const a=vs[i], b=vs[(i+1)%6]; e.push({a,b,index:i}); } return e; }

// ======= GAME SETUP =======
function hardReset(){
  state.running=false; state.paused=false; pauseBtn.textContent='Pause';
  state.angle=0; state.score=0; state.lives=CFG.startLives; state.level=1; state.balls=[]; state.redBallId=null;
  updateHud(); draw();
}
function resetRound(){
  // build new level with one red + N normals
  state.balls=[];
  const red=makeBall('red'); state.redBallId=red.id; state.balls.push(red);
  for(let i=0;i<CFG.baseBalls+(state.level-1);i++) state.balls.push(makeBall('normal'));
  updateHud();
}

let nextBallId=1;
function rand(min,max){ return Math.random()*(max-min)+min; }
function overlapsAny(p, rad){ return state.balls.some(b=> Math.hypot(p.x-b.x,p.y-b.y) < (rad+b.r+4)); }
function makeBall(type='normal'){
  const id=nextBallId++;
  const isRed = type==='red';
  const r = isRed ? rand(12,18) : rand(10,24);
  const speed = (isRed? rand(...CFG.redSpeedRange) : rand(...CFG.normalSpeedRange)) * CFG.speedMul;
  const dir = rand(0,Math.PI*2);
  const bounce = isRed? CFG.redBounce : rand(...CFG.normalBounceRange);
  // place near center without overlap
  let pos={x:0,y:0}, tries=0; do{ tries++; const rr=rand(0, CFG.worldScale*0.45); const th=rand(0,Math.PI*2); pos={x:rr*Math.cos(th), y:rr*Math.sin(th)}; } while(overlapsAny(pos,r)&&tries<300);
  return { id, type, x:pos.x, y:pos.y, vx:speed*Math.cos(dir), vy:speed*Math.sin(dir), r, bounce };
}

// ======= PHYSICS =======
function step(dt){
  // rotate arena
  const rot=1.8; if(keys.has('ArrowLeft')) state.angle-=rot*dt; if(keys.has('ArrowRight')) state.angle+=rot*dt;
  // integrate
  for(const b of state.balls){ b.x+=b.vx*dt; b.y+=b.vy*dt; }
  // wall collisions
  handleHexCollisions();
  // scoring
  state.score += CFG.timeScoreRate*dt; 
  // escapes
  checkEscapes();
}

function handleHexCollisions(){
  const edges=edgeList(state.angle);
  const openIdx=CFG.openEdgeIndex;
  for(const b of state.balls){
    for(const e of edges){
      const Ax=e.a.x, Ay=e.a.y, Bx=e.b.x, By=e.b.y;
      const ABx=Bx-Ax, ABy=By-Ay;
      const APx=b.x-Ax, APy=b.y-Ay;
      const AB2=ABx*ABx+ABy*ABy;
      let t=(APx*ABx+APy*ABy)/AB2; t=Math.max(0,Math.min(1,t));
      if(e.index===openIdx) continue; // open edge
      const Qx=Ax+t*ABx, Qy=Ay+t*ABy;
      const dx=b.x-Qx, dy=b.y-Qy; const dist=Math.hypot(dx,dy);
      if(dist < b.r){
        const nx=dx/(dist||1e-6), ny=dy/(dist||1e-6);
        const overlap=b.r-dist+0.01; b.x+=nx*overlap; b.y+=ny*overlap;
        // reflect
        const vdotn=b.vx*nx + b.vy*ny; if(vdotn<0){
          const eRest=b.bounce; b.vx -= (1+eRest)*vdotn*nx; b.vy -= (1+eRest)*vdotn*ny; if (b.type==='red') playBounce();
        }
      }
    }
  }
}

function checkEscapes(){
  const edges=edgeList(state.angle); const open=edges[CFG.openEdgeIndex];
  const nx=(open.b.y-open.a.y), ny=-(open.b.x-open.a.x); const nlen=Math.hypot(nx,ny); const onx=nx/nlen, ony=ny/nlen;
  const apothem=Math.abs(open.a.x*onx + open.a.y*ony);
  const remain=[]; let redOut=false; let nonTargetOut=false;
  for(const b of state.balls){
    const d=b.x*onx + b.y*ony; const outside = d > apothem + b.r;
    if(outside){ if(b.type==='red') redOut=true; else nonTargetOut=true; }
    else remain.push(b);
  }
  if(redOut){
    playDing();
    state.balls = remain.filter(b=>b.type!=='red');
    state.score = Math.round(state.score + CFG.levelClearBonus);
    state.level++;
    // add new red + one extra non-target
    const red=makeBall('red'); state.redBallId=red.id; state.balls.push(red); state.balls.push(makeBall('normal'));
  } else if (nonTargetOut){
    state.balls = remain; state.lives -= 1; if(state.lives<=0) return gameOver();
  }
  updateHud();
}

function gameOver(){ state.running=false; startBtn.disabled=false; pauseBtn.disabled=true; alert(`Game Over — Final Score: ${Math.round(state.score)}`); }

// ======= RENDER =======
function drawHex(angle){
  const edges=edgeList(angle); const c=CFG.colors; ctx.save(); ctx.translate(canvas.width/2,canvas.height/2);
  // fill
  ctx.beginPath(); const v=getHexVertices(angle); ctx.moveTo(v[0].x,v[0].y); for(let i=1;i<6;i++) ctx.lineTo(v[i].x,v[i].y); ctx.closePath(); ctx.fillStyle='rgba(59,130,246,0.05)'; ctx.fill();
  // edges
  for(const e of edges){ if(e.index===CFG.openEdgeIndex) continue; ctx.beginPath(); ctx.moveTo(e.a.x,e.a.y); ctx.lineTo(e.b.x,e.b.y); ctx.strokeStyle=c.edge; ctx.lineWidth=6; ctx.shadowColor=c.edgeGlow; ctx.shadowBlur=12; ctx.stroke(); }
  // open edge dashed
  const oe=edges[CFG.openEdgeIndex]; ctx.beginPath(); ctx.moveTo(oe.a.x,oe.a.y); ctx.lineTo(oe.b.x,oe.b.y); ctx.setLineDash([10,10]); ctx.strokeStyle='rgba(226,232,240,0.25)'; ctx.lineWidth=2; ctx.shadowBlur=0; ctx.stroke(); ctx.setLineDash([]);
  ctx.restore();
}
function drawBalls(){
  const c=CFG.colors; ctx.save(); ctx.translate(canvas.width/2,canvas.height/2);
  for(const b of state.balls){
    if(b.type==='red'){
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle=c.red; ctx.globalAlpha=.2; ctx.fill(); ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle=c.redOutline; ctx.shadowColor=c.redOutline; ctx.shadowBlur=12; ctx.stroke();
    } else {
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle=c.normal; ctx.globalAlpha=.2; ctx.fill(); ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle=c.normalOutline; ctx.shadowColor=c.normalOutline; ctx.shadowBlur=12; ctx.stroke();
    }
  }
  ctx.restore();
}
function draw(){
  // bg
  const g=ctx.createRadialGradient(canvas.width/2,canvas.height/2,60, canvas.width/2,canvas.height/2, canvas.width/2);
  g.addColorStop(0, CFG.colors.bg1); g.addColorStop(1, CFG.colors.bg0); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  drawHex(state.angle); drawBalls();
}

function updateHud(){ scoreEl.textContent=`Score: ${Math.round(state.score)}`; livesEl.textContent=`Lives: ${state.lives}`; levelEl.textContent=`Level: ${state.level}`; }

// ======= LOOP =======
function loop(t){ if(!state.running||state.paused) return; const dtReal=Math.min(0.033,(t-state.lastFrame)/1000); state.lastFrame=t; let acc=dtReal; while(acc>1e-8){ const stepDt=Math.min(CFG.dt,acc); step(stepDt); acc-=stepDt; } draw(); requestAnimationFrame(loop); }

// Responsive layout sizing
function layout(){
  const vw = window.innerWidth; const vh = window.innerHeight;
  const padding = 32; // wrap horizontal padding
  // Initial max width based on viewport
  let maxW = Math.min(vw - padding, 860);
  const frames = document.querySelectorAll('.frame');
  frames.forEach(el => el.style.width = maxW + 'px');
  const title = document.querySelector('.title');
  const topbar = document.querySelector('.topbar');
  const stats = document.querySelector('.stats');
  const controls = document.querySelector('.controls');
  const topH = (title?.offsetHeight||0) + (topbar?.offsetHeight||0) + (stats?.offsetHeight||0);
  const bottomH = (controls?.offsetHeight||0);
  const gaps = 14*3 + 8; // grid gaps + small buffer
  const availH = vh - topH - bottomH - gaps - 16;
  const target = Math.max(220, Math.min(maxW, availH));
  canvas.style.width = canvas.style.height = target + 'px';
  frames.forEach(el => el.style.width = target + 'px');
}
window.addEventListener('resize', layout);
window.addEventListener('orientationchange', ()=> setTimeout(layout, 250));
layout();
// boot idle frame
draw();
</script>
</body>
</html>
